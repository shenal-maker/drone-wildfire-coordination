<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Experiment 1 — Burnbot Treatment Optimizer</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Outfit:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/deck.gl@8.9.35/dist.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
:root {
  --bg:#0a0c10;--bg2:#11141c;--bg3:#181c28;--border:#1e2436;
  --text:#e8ecf4;--text2:#7a8299;--muted:#4a5068;
  --fire:#ff4d1a;--orange:#ff8c42;--cyan:#00e5ff;
  --green:#00e676;--yellow:#ffab00;--red:#f44336;--purple:#7c4dff;
}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Outfit',sans-serif;background:var(--bg);color:var(--text);overflow:hidden;height:100vh}
.app{display:flex;height:100vh}
.sidebar{width:380px;min-width:380px;background:var(--bg2);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow-y:auto;z-index:10}
.sidebar::-webkit-scrollbar{width:4px}
.sidebar::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.header{padding:20px 24px 16px;border-bottom:1px solid var(--border)}
.logo{font-family:'JetBrains Mono',monospace;font-size:18px;font-weight:700;letter-spacing:4px;background:linear-gradient(135deg,var(--orange),var(--cyan));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.logo-sub{font-size:11px;color:var(--muted);font-family:'JetBrains Mono',monospace;margin-top:2px}
.section{padding:14px 24px;border-bottom:1px solid var(--border)}
.section-label{font-family:'JetBrains Mono',monospace;font-size:10px;font-weight:500;letter-spacing:2px;color:var(--muted);text-transform:uppercase;margin-bottom:10px}
.row{display:flex;justify-content:space-between;font-size:11px;color:var(--text2);padding:3px 0;font-family:'JetBrains Mono',monospace}
.row .v{color:var(--text);font-weight:600}
.btn{padding:10px 16px;border-radius:8px;border:1px solid var(--border);background:var(--bg3);color:var(--text2);font-family:'JetBrains Mono',monospace;font-size:12px;cursor:pointer;transition:all .2s;width:100%;text-align:center;margin-top:6px}
.btn:hover{border-color:var(--cyan);color:var(--text)}
.btn-fire{border-color:var(--fire);color:var(--fire)}
.btn-fire:hover{background:rgba(255,77,26,.1)}
.legend{display:flex;flex-wrap:wrap;gap:8px}
.leg{display:flex;align-items:center;gap:4px;font-size:10px;color:var(--text2);font-family:'JetBrains Mono',monospace}
.dot{width:10px;height:10px;border-radius:50%;flex-shrink:0}
#fire-log{font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text2);max-height:100px;overflow-y:auto;background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:6px;line-height:1.6;margin-top:8px}
.map-wrap{flex:1;position:relative}
#map{width:100%;height:100%}
.param-grid{display:grid;grid-template-columns:1fr 1fr;gap:4px 12px}
.wui-tag{display:inline-block;font-size:9px;padding:1px 5px;border-radius:3px;background:rgba(124,77,255,.15);color:var(--purple);font-family:'JetBrains Mono',monospace;margin:1px}
.results-table{width:100%;border-collapse:collapse;font-family:'JetBrains Mono',monospace;font-size:9px;margin-top:8px}
.results-table th,.results-table td{padding:4px 6px;border:1px solid var(--border);text-align:right}
.results-table th{background:var(--bg);color:var(--muted);text-transform:uppercase;letter-spacing:1px;font-size:8px;text-align:center}
.results-table td:first-child{text-align:left;color:var(--text);font-weight:600}
.results-table tr.best td{color:var(--green)}
.chart-box{background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:8px;margin-top:8px;overflow:hidden}
.chart-box svg{width:100%;display:block}
.progress-bar{width:100%;height:6px;background:var(--bg);border-radius:3px;overflow:hidden;margin-top:6px}
.progress-fill{height:100%;background:var(--cyan);border-radius:3px;transition:width .3s}
.strat-select{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px}
.strat-chip{font-size:9px;padding:3px 8px;border-radius:4px;border:1px solid var(--border);background:var(--bg3);color:var(--text2);cursor:pointer;font-family:'JetBrains Mono',monospace}
.strat-chip.on{border-color:var(--cyan);color:var(--cyan);background:rgba(0,229,255,.08)}
.exp-toggle.on{border-color:var(--cyan);color:var(--cyan);background:rgba(0,229,255,.08)}
.caption{font-size:10px;color:var(--text2);font-family:'Outfit',sans-serif;line-height:1.5;margin-top:6px;padding:6px 8px;background:rgba(255,255,255,.02);border-left:2px solid var(--border);border-radius:0 4px 4px 0}
.caption em{color:var(--muted);font-style:normal}
.caption strong{color:var(--text);font-weight:600}
</style>
</head>
<body>
<div class="app">
<div class="sidebar">
  <div class="header">
    <div class="logo" id="exp-title">EXPERIMENT 1</div>
    <div class="logo-sub" id="exp-sub">Regional Scale — Butte & Plumas County</div>
    <div style="display:flex;gap:6px;margin-top:8px">
      <button class="btn exp-toggle on" data-exp="1" onclick="switchExperiment(1)" style="padding:6px 10px;width:auto;font-size:10px">Exp 1: Regional</button>
      <button class="btn exp-toggle" data-exp="2" onclick="switchExperiment(2)" style="padding:6px 10px;width:auto;font-size:10px">Exp 2: Paradise Zoom</button>
    </div>
  </div>

  <div class="section">
    <div class="section-label">Landscape</div>
    <div class="row"><span>Grid</span><span class="v" id="i-grid">—</span></div>
    <div class="row"><span>Cell size</span><span class="v" id="i-cellsize">~1.1 km (~250 ac)</span></div>
    <div class="row"><span>Operable (≤30°)</span><span class="v" id="i-op">—</span></div>
    <div class="row"><span>Marginal (20-30°)</span><span class="v" id="i-marg">—</span></div>
    <div class="row"><span>Inoperable (>30°)</span><span class="v" id="i-inop">—</span></div>
    <div class="row"><span>WUI cells</span><span class="v" id="i-wui">—</span></div>
    <div class="row"><span>Fire risk cells</span><span class="v" id="i-risk">—</span></div>
    <div style="margin-top:6px;font-size:10px;color:var(--muted)">
      WUI communities (2.4km buffer):
      <div style="margin-top:4px" id="wui-tags"></div>
    </div>
  </div>

  <div class="section">
    <div class="section-label">Rothermel Fire Model Parameters</div>
    <div class="param-grid">
      <div class="row"><span>Fuel model</span><span class="v">SH5 (chaparral)</span></div>
      <div class="row"><span>1-hr FM</span><span class="v" id="p-fm1">5%</span></div>
      <div class="row"><span>Live FM</span><span class="v" id="p-fml">75%</span></div>
      <div class="row"><span>Wind speed</span><span class="v" id="p-ws">15 km/h</span></div>
      <div class="row"><span>Wind dir</span><span class="v" id="p-wd">315° (NW)</span></div>
      <div class="row"><span>Slope factor</span><span class="v">2× per 20°</span></div>
      <div class="row"><span>Base ROS</span><span class="v" id="p-ros">1.2 km/h</span></div>
      <div class="row"><span>Treatment effect</span><span class="v">Conditional</span></div>
    </div>
    <div style="margin-top:6px;font-size:10px;color:var(--muted)">
      Treatment reduces spread 40-85% depending on wind/moisture.
      Based on meta-analysis (62-72% mean reduction).
    </div>
  </div>

  <div class="section">
    <div class="section-label">Fire Spread Test</div>
    <p style="font-size:11px;color:var(--text2);margin-bottom:6px">Click map cell to ignite, or:</p>
    <button class="btn btn-fire" onclick="igniteRandom()">Ignite Random Cell</button>
    <button class="btn" onclick="resetFire()">Reset Fire</button>
    <div id="fire-log"></div>
  </div>

  <div class="section">
    <div class="section-label">Experiment Configuration</div>

    <div style="font-size:10px;color:var(--muted);font-family:'JetBrains Mono',monospace;margin-bottom:8px">FLEET</div>
    <div class="row"><span>Fleet size</span><span class="v"><input id="fleet-size" type="number" min="2" max="12" value="6" style="width:40px;background:var(--bg);border:1px solid var(--border);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:11px;text-align:center;border-radius:4px;padding:2px"> Burnbots</span></div>
    <div class="row"><span>Campaign</span><span class="v">2 weeks (140 hrs/unit)</span></div>
    <div class="row"><span>MC runs</span><span class="v">100 per strategy</span></div>

    <div style="font-size:10px;color:var(--muted);font-family:'JetBrains Mono',monospace;margin:10px 0 6px">WEATHER SCENARIO</div>
    <div style="display:flex;flex-direction:column;gap:4px">
      <label style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="radio" name="weather" value="mixed" checked style="accent-color:var(--cyan)"> Mixed (70% normal / 30% Diablo)
      </label>
      <label style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="radio" name="weather" value="normal"> Normal only (summer)
      </label>
      <label style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="radio" name="weather" value="diablo"> Diablo wind only
      </label>
    </div>

    <div style="font-size:10px;color:var(--muted);font-family:'JetBrains Mono',monospace;margin:10px 0 6px">STRATEGIES TO RUN</div>
    <div style="display:flex;flex-direction:column;gap:4px">
      <label class="strat-check" style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="checkbox" value="Housing Protection" checked style="accent-color:var(--purple)"> Housing Protection
      </label>
      <label class="strat-check" style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="checkbox" value="Fire Transmission" checked style="accent-color:var(--orange)"> Fire Transmission
      </label>
      <label class="strat-check" style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="checkbox" value="Highest Fuel" checked style="accent-color:var(--red)"> Highest Fuel
      </label>
      <label class="strat-check" style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="checkbox" value="DPV-Optimal" checked style="accent-color:var(--cyan)"> DPV-Optimal
      </label>
      <label class="strat-check" style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;cursor:pointer;display:flex;align-items:center;gap:6px">
        <input type="checkbox" value="Constrained DPV" checked style="accent-color:var(--green)"> Constrained DPV ★
      </label>
    </div>

    <button class="btn" id="btn-run" onclick="runExperiment()" style="margin-top:10px">Run Experiment</button>
    <div class="progress-bar" id="prog-wrap" style="display:none"><div class="progress-fill" id="prog"></div></div>
    <div id="run-status" style="font-size:10px;color:var(--muted);margin-top:4px;font-family:'JetBrains Mono',monospace"></div>
  </div>

  <div class="section" id="sec-live-chart" style="display:none">
    <div class="section-label">Live — Damage per Run</div>
    <div class="chart-box" id="chart-live" style="height:160px"></div>
    <div class="caption">
      Each line shows the <strong>running average of damage-weighted burn area</strong> as Monte Carlo runs complete.
      Lines converge as more runs accumulate — stable convergence by ~60-80 runs indicates sufficient sample size.
      The dashed baseline (no treatment) provides the control.
      Weather is sampled independently per run from a fire-season distribution <em>(70% normal summer, 30% Diablo wind events — Moritz et al. 2010)</em>.
    </div>
  </div>

  <div class="section" id="sec-map-strat" style="display:none">
    <div class="section-label">Burnbot Treatment Map</div>
    <div class="caption" style="margin-bottom:8px">
      <strong>White lines on the map show firebreak locations</strong> — where Burnbot units performed prescribed burns.
      Each strategy places treatments differently. Click a strategy below to see its spatial pattern.
      Treatment budget = fleet size × 140 hrs at 1 acre/hr. Scattered strategies lose hours to travel (20 km/h between parcels).
    </div>
    <div class="strat-select" id="strat-chips"></div>
    <div id="map-strat-info" style="font-size:10px;color:var(--muted);margin-top:6px;font-family:'JetBrains Mono',monospace"></div>
  </div>

  <div class="section" id="sec-results" style="display:none">
    <div class="section-label">Results — Strategy Comparison</div>
    <div id="results-table-wrap"></div>
    <div class="caption">
      <strong>Damage</strong> = Σ(burned cells × value-at-risk), where WUI cells carry weight up to 10 and wildland = 1 <em>(Thompson et al. 2022)</em>.
      <strong>Reduction</strong> = % decrease vs. no-treatment baseline.
      All strategies share the same 100 ignition points (paired comparison) and weather draws, isolating treatment placement as the sole variable.
      Green row = lowest mean damage.
    </div>

    <div class="section-label" style="margin-top:12px">Damage by Strategy</div>
    <div class="chart-box" id="chart-damage" style="height:160px"></div>
    <div class="caption">
      Bar height = mean damage across 100 runs. Error bars = ±1 standard deviation.
      Fire spread uses a <strong>simplified Rothermel model</strong> <em>(Rothermel 1972; Andrews 2018)</em>:
      ROS = baseROS × moisture damping × slope factor × wind alignment × fuel load.
      Treatment reduces spread probability by 35–90% depending on wind speed and fuel moisture <em>(meta-analysis benchmark: 62–72%, Fernandes &amp; Botelho 2003)</em>.
    </div>

    <div class="section-label" style="margin-top:12px">Pareto Front (WUI vs Wildland)</div>
    <div class="chart-box" id="chart-pareto" style="height:160px"></div>
    <div class="caption">
      The <strong>fundamental tradeoff</strong>: protecting communities (low WUI damage, Y-axis) vs. preserving wildland (low wildland burn, X-axis).
      Points closer to the bottom-left are better on both axes. The Pareto front reveals which strategies are dominated.
      <em>This tradeoff framework follows Pais et al. (2021) "Downstream Protection Value" and Thompson et al. (2022) risk-based prioritization.</em>
    </div>

    <div class="section-label" style="margin-top:12px">Efficiency Metrics</div>
    <div id="efficiency-table-wrap"></div>
    <div class="caption">
      <strong>WUI Saved/Acre</strong> = (baseline WUI damage − strategy WUI damage) / acres treated. Higher = more efficient use of Burnbot time.
      <strong>Wildland Cost/WUI</strong> = increase in wildland burn per unit of WUI damage prevented. Strategies that cluster near WUI may sacrifice wildland protection.
      <em>Novel metric: no published work evaluates treatment efficiency under robotic operational constraints (travel time, slope feasibility).</em>
    </div>

    <div class="section-label" style="margin-top:12px">Robustness by Ignition Stratum</div>
    <div id="stratum-table-wrap"></div>
    <div class="caption">
      Ignition points are stratified by <strong>NASA FIRMS hotspot density</strong> into quartiles (Q1=low-risk, Q4=high-risk).
      Q4 receives 40% of samples; Q1 receives 10% — testing both historical fire zones and unexpected ignition locations.
      A robust strategy performs well across all strata, not just where fires historically start.
      <em>Stratified sampling follows standard Monte Carlo variance reduction techniques (Fishman 1996).</em>
    </div>
  </div>

  <div class="section">
    <div class="section-label">Legend</div>
    <div class="legend">
      <div class="leg"><div class="dot" style="background:#2e7d32"></div>Operable</div>
      <div class="leg"><div class="dot" style="background:#f9a825"></div>Marginal</div>
      <div class="leg"><div class="dot" style="background:#c62828"></div>Inoperable</div>
      <div class="leg"><div class="dot" style="background:var(--purple)"></div>WUI</div>
      <div class="leg"><div class="dot" style="background:var(--fire);box-shadow:0 0 6px var(--fire)"></div>Burning</div>
      <div class="leg"><div class="dot" style="background:#444"></div>Burned</div>
      <div class="leg"><div class="dot" style="background:var(--cyan)"></div>FIRMS</div>
      <div class="leg"><div class="dot" style="background:#0af5"></div>Treated</div>
      <div class="leg"><div class="dot" style="background:#fff;width:10px;height:2px;border-radius:0"></div>Firebreak</div>
    </div>
  </div>

  <div class="section">
    <div class="section-label">Data Sources</div>
    <div style="font-size:10px;color:var(--text2);font-family:'JetBrains Mono',monospace;line-height:1.8">
      Fire ignition: NASA FIRMS VIIRS (embedded)<br>
      Terrain: Modeled from USGS NED profiles<br>
      Fuel model: NWCG SH5 (high-load chaparral)<br>
      Spread: Simplified Rothermel (1972)<br>
      Burnbot: RX2 — 1 ac/hr, ≤30° slope, ≤32 km/h wind<br>
      WUI buffer: CAL FIRE standard 2.4 km
    </div>
  </div>
</div>

<div class="map-wrap"><div id="map"></div></div>
</div>

<script>
// ═══════════════════════════════════════════════════════
//  CONSTANTS & DATA
// ═══════════════════════════════════════════════════════

// FIRMS hotspots [lat, lng, frp] — Camp Fire, Dixie Fire, North Complex
const FIRMS = [
  [39.764,-121.606,142],[39.778,-121.585,118],[39.751,-121.622,135],[39.790,-121.570,89],
  [39.740,-121.640,110],[39.802,-121.555,76],[39.770,-121.615,128],[39.755,-121.590,95],
  [40.140,-121.180,165],[40.120,-121.150,140],[40.160,-121.200,115],[40.100,-121.130,100],
  [40.180,-121.220,125],[40.080,-121.100,88],[40.150,-121.170,148],[40.200,-121.250,80],
  [39.820,-121.400,105],[39.840,-121.380,92],[39.800,-121.420,112],[39.860,-121.360,85],
  [39.780,-121.440,130],[39.880,-121.350,70],[39.830,-121.390,108],[39.810,-121.410,97],
  [39.750,-121.500,65],[39.730,-121.520,58],[39.770,-121.480,82],[39.710,-121.540,68],
  [39.900,-121.300,62],[39.920,-121.320,55],[39.880,-121.280,72],[39.940,-121.340,50],
  [39.720,-121.650,90],[39.700,-121.680,82],[39.740,-121.620,100],[39.760,-121.580,86],
  [40.050,-121.080,106],[40.030,-121.050,90],[40.070,-121.100,120],[40.010,-121.020,80],
  [40.090,-121.120,112],[39.990,-121.000,75],[40.040,-121.070,132],[40.020,-121.030,88],
  [39.850,-121.700,60],[39.830,-121.720,52],[39.870,-121.680,66],[39.890,-121.660,48]
];

// WUI communities — [name, lat, lng] (centroids)
const COMMUNITIES = [
  ['Paradise', 39.7596, -121.6220],
  ['Concow', 39.7520, -121.5400],
  ['Magalia', 39.8120, -121.5780],
  ['Stirling City', 39.8980, -121.5260],
  ['Berry Creek', 39.6480, -121.4020],
  ['Feather Falls', 39.6210, -121.2700],
  ['Greenville', 40.1398, -121.1028],
  ['Indian Falls', 40.0700, -121.1400],
];
const WUI_BUFFER_KM = 2.4;
const WUI_BUFFER_DEG = WUI_BUFFER_KM / 111.32; // approximate

// Grid configs per experiment
const EXP_CONFIGS = {
  1: { lngMin:-121.85, lngMax:-120.95, latMin:39.65, latMax:40.25, step:0.01,
       label:'EXPERIMENT 1', sub:'Regional Scale — Butte & Plumas County', zoom:9, center:[-121.35,39.95] },
  2: { lngMin:-121.72, lngMax:-121.50, latMin:39.70, latMax:39.86, step:0.001,
       label:'EXPERIMENT 2', sub:'Paradise Sub-Landscape — 100m cells', zoom:12.5, center:[-121.61,39.78] },
};
let currentExp = 1;
let G = { ...EXP_CONFIGS[1] };
let CELL_SIZE_M = G.step * 111320;
let CELL_AREA_ACRES = (CELL_SIZE_M * CELL_SIZE_M) / 4047;

// Rothermel parameters for SH5 (high-load, dry-climate shrub)
const ROTHERMEL = {
  fuelModel: 'SH5',
  fuelBedDepth_m: 1.83,        // 6 ft fuel bed
  ovenDryLoad_kg_m2: 1.68,     // total fuel loading
  SAV_ratio: 4921,              // surface-area-to-volume (1/ft converted)
  heatContent_kJ_kg: 18608,    // heat content
  mineralDamping: 0.174,        // effective mineral content damping
  baseROS_km_h: 1.2,           // base rate of spread in moderate conditions
  slopeFactor: 2.0,            // ROS multiplier per 20° upslope
  // These vary per Monte Carlo run:
  deadFuelMoisture: 0.05,      // 5% (summer default)
  liveFuelMoisture: 0.75,      // 75%
  windSpeed_km_h: 15,
  windDir_deg: 315,
};

// Treatment effect: conditional on wind speed and fuel moisture
// Higher wind / lower moisture = treatment less effective
function treatmentReduction(windSpeed, deadFM) {
  // Base: 72% reduction (meta-analysis mean)
  // Degrades under extreme conditions
  const windPenalty = Math.max(0, (windSpeed - 20) / 60); // 0 at 20km/h, ~0.5 at 50km/h
  const moistureBonus = Math.max(0, (deadFM - 0.03) / 0.05); // drier = less effective
  const reduction = 0.72 - windPenalty * 0.32 + moistureBonus * 0.13;
  return Math.max(0.35, Math.min(0.90, reduction)); // clamp 35-90%
}

// ═══════════════════════════════════════════════════════
//  DETERMINISTIC HASH (for reproducible terrain)
// ═══════════════════════════════════════════════════════
function hash(x, y) {
  let h = (x * 374761393 + y * 668265263) | 0;
  h = Math.imul(h ^ (h >>> 13), 1274126177);
  return ((h ^ (h >>> 16)) >>> 0) / 4294967296;
}

// ═══════════════════════════════════════════════════════
//  BUILD LANDSCAPE GRID
// ═══════════════════════════════════════════════════════
const cells = [];
const RC = {}; // "row,col" -> index
let nCols = 0, nRows = 0;

function buildGrid() {
  let row = 0;
  for (let lat = G.latMin; lat <= G.latMax; lat += G.step) {
    let col = 0;
    for (let lng = G.lngMin; lng <= G.lngMax; lng += G.step) {
      // --- ELEVATION ---
      const ef = (lng - G.lngMin) / (G.lngMax - G.lngMin); // 0 (west) to 1 (east)
      const nf = (lat - G.latMin) / (G.latMax - G.latMin);

      // Base: Sacramento Valley ~50m, Sierra crest ~2200m (non-linear rise)
      const base = 50 + Math.pow(ef, 1.4) * 2150;

      // Feather River Canyon: runs NW-SE, cuts 300-600m below ridges
      const cAxis = (lat - 39.65) * 1.2 + (lng + 121.4) * 0.8;
      const cDist = Math.abs(cAxis - Math.sin(lng * 12) * 0.15);
      const canyon = Math.max(0, 1 - cDist * 8) * (300 + ef * 400);

      // West Branch canyon
      const c2Axis = (lat - 39.75) * 0.9 + (lng + 121.6) * 1.1;
      const c2Dist = Math.abs(c2Axis - Math.cos(lat * 15) * 0.1);
      const canyon2 = Math.max(0, 1 - c2Dist * 10) * (200 + ef * 300);

      // N-S ridgelines, sharper eastward
      const rAmp = 150 + ef * 400;
      const r1 = Math.abs(Math.sin(lng * 28 + 0.5)) * rAmp * 0.7;
      const r2 = Math.abs(Math.cos(lng * 42 + lat * 8)) * rAmp * 0.5;

      // Paradise bench (~550m flat area)
      const pDist = Math.hypot(lat - 39.76, lng + 121.60);
      const bench = Math.max(0, 1 - pDist * 12) * 150;

      // Local roughness from hash
      const h1 = hash(Math.round(lat * 500), Math.round(lng * 500));
      const h2 = hash(Math.round(lat * 200), Math.round(lng * 200));
      const rough = (h1 - 0.5) * 200 * ef + (h2 - 0.5) * 120;

      const elev = Math.max(20, base - canyon - canyon2 + r1 + r2 + bench + rough);

      // --- FUEL LOAD (0-1) ---
      // Peaks at mid-elevation (chaparral/mixed conifer 400-1200m)
      const elevNorm = Math.min(1, elev / 2000);
      const fuelBase = Math.sin(elevNorm * Math.PI) * 0.85;
      const fuelNoise = (hash(Math.round(lat * 300), Math.round(lng * 300)) - 0.3) * 0.3;
      const fuel = Math.max(0.05, Math.min(1.0, fuelBase + fuelNoise));

      // --- IGNITION PROBABILITY (from FIRMS density) ---
      let ignBoost = 0;
      for (const [flat, flng, frp] of FIRMS) {
        const d = Math.hypot(lat - flat, lng - flng);
        if (d < 0.1) ignBoost += (frp / 165) * (1 - d / 0.1);
      }
      const ignProb = Math.min(1, 0.01 + ignBoost * 0.12);

      // --- WUI ---
      let wuiWeight = 0;
      let nearestCommunity = null;
      for (const [name, clat, clng] of COMMUNITIES) {
        const d = Math.hypot(lat - clat, lng - clng);
        if (d < WUI_BUFFER_DEG) {
          const w = 10 * (1 - d / WUI_BUFFER_DEG); // 10 at center, 0 at edge
          if (w > wuiWeight) { wuiWeight = w; nearestCommunity = name; }
        }
      }

      // --- VALUE AT RISK ---
      // WUI: up to 10, Timber (mid-high elev): 3, Wildland: 1
      const isTimber = elev > 600 && elev < 1800 && fuel > 0.4;
      const valueAtRisk = wuiWeight > 0 ? wuiWeight : (isTimber ? 3 : 1);

      const idx = cells.length;
      RC[`${row},${col}`] = idx;
      cells.push({
        row, col, idx,
        lat: +lat.toFixed(4), lng: +lng.toFixed(4),
        elev, fuel, ignProb, wuiWeight, nearestCommunity, valueAtRisk,
        slope: 0, operable: 'yes',
        // Mutable fire state (reset between runs)
        burning: false, burned: false, treated: false, burnTimer: 0
      });
      col++;
    }
    if (row === 0) nCols = col;
    row++;
  }
  nRows = row;

  // --- COMPUTE SLOPE ---
  for (const c of cells) {
    let maxSlope = 0;
    for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
      const ni = RC[`${c.row+dr},${c.col+dc}`];
      if (ni !== undefined) {
        const dE = Math.abs(cells[ni].elev - c.elev);
        const s = Math.atan(dE / CELL_SIZE_M) * 180 / Math.PI;
        if (s > maxSlope) maxSlope = s;
      }
    }
    c.slope = maxSlope;
    c.operable = maxSlope <= 20 ? 'yes' : maxSlope <= 30 ? 'marginal' : 'no';
  }

  updateSidebar();
}

function updateSidebar() {
  const op = cells.filter(c => c.operable === 'yes').length;
  const ma = cells.filter(c => c.operable === 'marginal').length;
  const no = cells.filter(c => c.operable === 'no').length;
  const wui = cells.filter(c => c.wuiWeight > 0).length;
  const risk = cells.filter(c => c.ignProb > 0.03).length;

  document.getElementById('i-cellsize').textContent = CELL_SIZE_M > 500 ? `~${(CELL_SIZE_M/1000).toFixed(1)} km (~${CELL_AREA_ACRES.toFixed(0)} ac)` : `~${CELL_SIZE_M.toFixed(0)}m (~${CELL_AREA_ACRES.toFixed(1)} ac)`;
  document.getElementById('i-grid').textContent = `${nRows}×${nCols} (${cells.length})`;
  document.getElementById('i-op').textContent = `${op} (${(op/cells.length*100)|0}%)`;
  document.getElementById('i-marg').textContent = `${ma} (${(ma/cells.length*100)|0}%)`;
  document.getElementById('i-inop').textContent = `${no} (${(no/cells.length*100)|0}%)`;
  document.getElementById('i-wui').textContent = `${wui}`;
  document.getElementById('i-risk').textContent = `${risk}`;

  // WUI tags
  const tags = document.getElementById('wui-tags');
  tags.innerHTML = COMMUNITIES.map(([n]) => `<span class="wui-tag">${n}</span>`).join(' ');
}

// ═══════════════════════════════════════════════════════
//  SIMPLIFIED ROTHERMEL FIRE SPREAD
// ═══════════════════════════════════════════════════════
//
// Rate of Spread (ROS) for a cell-to-cell transition:
//   ROS = baseROS × moistureFactor × slopeFactor × windFactor
//
// Spread probability per tick = ROS_effective / cellSize × tickDuration
//
// References:
//   Rothermel (1972) "A mathematical model for predicting fire spread"
//   Andrews (2018) "The Rothermel surface fire spread model and associated developments"
//   NWCG PMS 437 Surface Fire Behavior Lookup Tables

// Tick duration scales with cell size so spread probabilities stay in [0,1]
function getTickMinutes() { return CELL_SIZE_M > 500 ? 30 : 5; }
const TICK_MS = 350;          // visual animation speed

function moistureDamping(deadFM) {
  // Simplified moisture damping from Rothermel
  // At 3% FM: factor ~1.3 (very dry, burns fast)
  // At 8% FM: factor ~0.6 (moderate, slower)
  // At 15% FM: factor ~0.1 (damp, barely spreads)
  const r = deadFM / 0.15; // ratio to extinction moisture (~15% for SH5)
  return Math.max(0.05, 1.0 - 2.5 * r + 1.5 * r * r);
}

function slopeFactor(elevDiff) {
  // Fire spreads faster uphill: doubles per 20° slope (Rothermel slope factor)
  // elevDiff > 0 means neighbor is uphill
  if (elevDiff <= 0) {
    // Downhill: reduced but not zero
    return Math.max(0.3, 1.0 + elevDiff / (CELL_SIZE_M * 0.8));
  }
  const slopeDeg = Math.atan(elevDiff / CELL_SIZE_M) * 180 / Math.PI;
  return Math.pow(ROTHERMEL.slopeFactor, slopeDeg / 20);
}

function windFactor(dr, dc, windDir, windSpeed) {
  // Wind pushes fire in the direction it's blowing toward
  // windDir is meteorological (where wind comes FROM), fire travels opposite
  const fireDir = (windDir + 180) % 360;
  const fireDirRad = fireDir * Math.PI / 180;
  // Direction of this spread (row/col delta to angle)
  const spreadAngle = Math.atan2(dc, -dr); // -dr because row increases southward
  const alignment = Math.cos(spreadAngle - fireDirRad);
  // Wind effect scales with speed: at 40km/h, headwind spread is 3x; tailwind is 0.3x
  const intensity = windSpeed / 30;
  return Math.max(0.15, 1.0 + alignment * intensity);
}

// Compute spread probability from cell i to neighbor ni
function spreadProb(cell, neighbor, params) {
  const baseROS = params.baseROS_km_h || ROTHERMEL.baseROS_km_h;
  const mf = moistureDamping(params.deadFuelMoisture);
  const elevDiff = neighbor.elev - cell.elev;
  const sf = slopeFactor(elevDiff);
  const dr = neighbor.row - cell.row;
  const dc = neighbor.col - cell.col;
  const wf = windFactor(dr, dc, params.windDir_deg, params.windSpeed_km_h);

  // Effective ROS in km/h
  const ros = baseROS * mf * sf * wf * neighbor.fuel;

  // Convert to spread probability per tick
  // tick = 30 min, cell = ~1.1km → prob = ros * 0.5hr / 1.1km
  let prob = ros * (getTickMinutes() / 60) / (CELL_SIZE_M / 1000);

  // Treatment: conditional reduction
  if (neighbor.treated) {
    const reduction = treatmentReduction(params.windSpeed_km_h, params.deadFuelMoisture);
    prob *= (1 - reduction);
  }

  return Math.max(0, Math.min(0.95, prob));
}

// ═══════════════════════════════════════════════════════
//  HEADLESS FIRE SIMULATION (for Monte Carlo)
// ═══════════════════════════════════════════════════════
// Returns { burnedCells: [...indices], totalDamage, wuiDamage, wildlandBurned, ticks }
function simulateFire(ignitionIdx, params, treatedSet) {
  // Reset cell states
  const burning = new Uint8Array(cells.length);
  const burned = new Uint8Array(cells.length);
  const timers = new Uint8Array(cells.length);

  burning[ignitionIdx] = 1;
  let activeFires = 1;
  let ticks = 0;
  const maxTicks = CELL_SIZE_M > 500 ? 200 : 600; // scale with cell size

  while (activeFires > 0 && ticks < maxTicks) {
    ticks++;
    const toIgnite = [];
    const toBurnOut = [];

    for (let i = 0; i < cells.length; i++) {
      if (!burning[i]) continue;
      timers[i]++;

      // Burn duration depends on fuel load
      if (timers[i] > 2 + cells[i].fuel * 6) {
        toBurnOut.push(i);
        continue;
      }

      // Try spreading to 4 neighbors
      const c = cells[i];
      for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
        const ni = RC[`${c.row+dr},${c.col+dc}`];
        if (ni === undefined) continue;
        if (burning[ni] || burned[ni]) continue;

        const isTreated = treatedSet ? treatedSet.has(ni) : false;
        const nb = cells[ni];
        const p = spreadProb(c, { ...nb, treated: isTreated }, params);
        if (Math.random() < p) toIgnite.push(ni);
      }
    }

    for (const i of toBurnOut) { burning[i] = 0; burned[i] = 1; activeFires--; }
    for (const i of toIgnite) {
      if (!burning[i] && !burned[i]) { burning[i] = 1; activeFires++; }
    }
  }

  // Compute damage
  let totalDamage = 0, wuiDamage = 0, wildlandBurned = 0;
  const burnedIndices = [];
  for (let i = 0; i < cells.length; i++) {
    if (burned[i] || burning[i]) {
      burnedIndices.push(i);
      totalDamage += cells[i].valueAtRisk;
      if (cells[i].wuiWeight > 0) wuiDamage += cells[i].wuiWeight;
      else wildlandBurned++;
    }
  }

  return { burnedCells: burnedIndices, totalDamage, wuiDamage, wildlandBurned, ticks };
}

// ═══════════════════════════════════════════════════════
//  VISUAL FIRE SPREAD (interactive, animated)
// ═══════════════════════════════════════════════════════
let fireInterval = null;

function igniteCell(idx) {
  if (idx < 0 || idx >= cells.length) return;
  const c = cells[idx];
  if (c.burning || c.burned) return;
  c.burning = true;
  c.burnTimer = 0;
  log(`Ignited [${c.row},${c.col}] elev=${c.elev|0}m fuel=${(c.fuel*100)|0}% slope=${c.slope.toFixed(1)}° val=${c.valueAtRisk.toFixed(1)}${c.wuiWeight > 0 ? ' (WUI:'+c.nearestCommunity+')' : ''}`);
  if (!fireInterval) startFireLoop();
}

function igniteRandom() {
  // Weighted by ignition probability
  const cands = cells.filter(c => !c.burning && !c.burned && c.ignProb > 0.02);
  if (!cands.length) return;
  const total = cands.reduce((s, c) => s + c.ignProb, 0);
  let r = Math.random() * total;
  for (const c of cands) { r -= c.ignProb; if (r <= 0) { igniteCell(c.idx); return; } }
  igniteCell(cands[cands.length - 1].idx);
}

function visualSpreadTick() {
  const toIgnite = [], toBurnOut = [];
  const params = { ...ROTHERMEL };

  for (const cell of cells) {
    if (!cell.burning) continue;
    cell.burnTimer++;
    if (cell.burnTimer > 2 + cell.fuel * 6) { toBurnOut.push(cell); continue; }

    for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
      const ni = RC[`${cell.row+dr},${cell.col+dc}`];
      if (ni === undefined) continue;
      const nb = cells[ni];
      if (nb.burning || nb.burned) continue;
      const p = spreadProb(cell, nb, params);
      if (Math.random() < p) toIgnite.push(nb);
    }
  }

  for (const c of toBurnOut) { c.burning = false; c.burned = true; }
  for (const c of toIgnite) { if (!c.burning && !c.burned) { c.burning = true; c.burnTimer = 0; } }

  renderDeck();

  const active = cells.filter(c => c.burning).length;
  if (active === 0 && fireInterval) {
    clearInterval(fireInterval);
    fireInterval = null;
    const b = cells.filter(c => c.burned).length;
    const dmg = cells.filter(c => c.burned).reduce((s, c) => s + c.valueAtRisk, 0);
    const wuiB = cells.filter(c => c.burned && c.wuiWeight > 0).length;
    log(`Fire out. ${b} cells burned (${(b/cells.length*100).toFixed(1)}%). Damage: ${dmg.toFixed(0)} (${wuiB} WUI cells).`);
  }
}

function startFireLoop() {
  if (fireInterval) return;
  fireInterval = setInterval(visualSpreadTick, TICK_MS);
}

function resetFire() {
  if (fireInterval) { clearInterval(fireInterval); fireInterval = null; }
  for (const c of cells) { c.burning = false; c.burned = false; c.burnTimer = 0; c.treated = false; }
  document.getElementById('fire-log').textContent = '';
  renderDeck();
}

function log(msg) {
  const el = document.getElementById('fire-log');
  el.textContent += msg + '\n';
  el.scrollTop = el.scrollHeight;
}

// ═══════════════════════════════════════════════════════
//  STRATIFIED IGNITION SAMPLING
// ═══════════════════════════════════════════════════════
// Divide landscape into 4 strata by FIRMS ignition density quartile.
// Sample ignition points proportionally from each stratum.
// Returns array of 100 cell indices (fixed across strategies).
function generateIgnitionSet(n = 100) {
  // Sort cells by ignition probability
  const operable = cells.filter(c => c.ignProb > 0.005 && c.fuel > 0.1);
  operable.sort((a, b) => a.ignProb - b.ignProb);

  const q = Math.floor(operable.length / 4);
  const strata = [
    operable.slice(0, q),           // Q1: low risk
    operable.slice(q, q * 2),       // Q2: moderate
    operable.slice(q * 2, q * 3),   // Q3: high
    operable.slice(q * 3),          // Q4: very high
  ];

  // Sample proportionally: more from high-risk strata
  const weights = [0.10, 0.20, 0.30, 0.40]; // 10% from Q1, 40% from Q4
  const ignitions = [];
  for (let s = 0; s < 4; s++) {
    const count = Math.round(n * weights[s]);
    for (let i = 0; i < count && ignitions.length < n; i++) {
      const cell = strata[s][Math.floor(Math.random() * strata[s].length)];
      ignitions.push({ idx: cell.idx, stratum: s + 1 });
    }
  }
  // Fill remainder if rounding left us short
  while (ignitions.length < n) {
    const cell = strata[3][Math.floor(Math.random() * strata[3].length)];
    ignitions.push({ idx: cell.idx, stratum: 4 });
  }

  return ignitions;
}

// ═══════════════════════════════════════════════════════
//  WEATHER SAMPLING (per Monte Carlo run)
// ═══════════════════════════════════════════════════════
function getWeatherMode() {
  const r = document.querySelector('input[name="weather"]:checked');
  return r ? r.value : 'mixed';
}

function sampleWeather(forceMode) {
  const mode = forceMode || getWeatherMode();
  const isDiablo = mode === 'diablo' ? true : mode === 'normal' ? false : Math.random() < 0.30;
  if (isDiablo) {
    return {
      deadFuelMoisture: 0.03 + Math.random() * 0.02,  // 3-5%
      liveFuelMoisture: 0.55 + Math.random() * 0.15,   // 55-70%
      windSpeed_km_h: 35 + Math.random() * 25,          // 35-60 km/h
      windDir_deg: 30 + Math.random() * 40,              // 30-70° (NE Diablo)
      baseROS_km_h: ROTHERMEL.baseROS_km_h,
      event: 'diablo'
    };
  }
  return {
    deadFuelMoisture: 0.04 + Math.random() * 0.04,  // 4-8%
    liveFuelMoisture: 0.60 + Math.random() * 0.30,   // 60-90%
    windSpeed_km_h: 10 + Math.random() * 15,          // 10-25 km/h
    windDir_deg: 240 + Math.random() * 120,            // 240-360° (W to N)
    baseROS_km_h: ROTHERMEL.baseROS_km_h,
    event: 'normal'
  };
}

// ═══════════════════════════════════════════════════════
//  MAP + DECK.GL
// ═══════════════════════════════════════════════════════
const map = new maplibregl.Map({
  container: 'map',
  style: {
    version: 8,
    sources: { 'carto': { type:'raster', tiles:['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'], tileSize:256 }},
    layers: [{ id:'carto', type:'raster', source:'carto' }]
  },
  center: [-121.35, 39.95], zoom: 9, pitch: 0, maxZoom: 13, minZoom: 7
});

let deckOverlay = null;

function cellColor(c) {
  if (c.burning) return [255, 60, 10, 210];
  if (c.burned) return [50, 50, 50, 170];
  if (c.treated) return [0, 170, 255, 130];
  // WUI overlay
  if (c.wuiWeight > 2) {
    const w = Math.min(1, c.wuiWeight / 10);
    return [124 * w + 30, 77 * w + 60, 255 * w + 20, 60 + w * 100];
  }
  // Operability + fuel intensity
  const f = c.fuel;
  if (c.operable === 'yes') return [25 + f * 25, 90 + f * 35, 35, 40 + f * 60];
  if (c.operable === 'marginal') return [200, 155, 30, 40 + f * 60];
  return [170, 30, 30, 40 + f * 60];
}

function buildFirebreakPaths() {
  // Build line segments along edges of treated cells (borders with untreated neighbors)
  const paths = [];
  const half = G.step / 2;
  for (const c of cells) {
    if (!c.treated) continue;
    for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
      const ni = RC[`${c.row+dr},${c.col+dc}`];
      if (ni !== undefined && cells[ni].treated) continue; // both treated, no edge
      // Draw a line segment on this edge
      let p1, p2;
      if (dr === -1) { p1 = [c.lng - half, c.lat + half]; p2 = [c.lng + half, c.lat + half]; }
      else if (dr === 1) { p1 = [c.lng - half, c.lat - half]; p2 = [c.lng + half, c.lat - half]; }
      else if (dc === -1) { p1 = [c.lng - half, c.lat - half]; p2 = [c.lng - half, c.lat + half]; }
      else { p1 = [c.lng + half, c.lat - half]; p2 = [c.lng + half, c.lat + half]; }
      paths.push({ path: [p1, p2] });
    }
  }
  return paths;
}

function renderDeck() {
  const firebreaks = buildFirebreakPaths();
  const layers = [
    new deck.ScatterplotLayer({
      id: 'grid', data: cells,
      getPosition: d => [d.lng, d.lat],
      getRadius: CELL_SIZE_M / 2.2,
      getFillColor: d => cellColor(d),
      radiusMinPixels: 3, radiusMaxPixels: 14,
      pickable: true,
      onClick: ({object}) => { if (object) igniteCell(object.idx); },
      updateTriggers: { getFillColor: [Date.now()] }
    }),
    new deck.PathLayer({
      id: 'firebreaks', data: firebreaks,
      getPath: d => d.path,
      getColor: [255, 255, 255, 200],
      getWidth: 80,
      widthMinPixels: 1.5,
      widthMaxPixels: 4,
      capRounded: true,
      updateTriggers: { getPath: [Date.now()] }
    }),
    new deck.ScatterplotLayer({
      id: 'firms', data: FIRMS,
      getPosition: d => [d[1], d[0]],
      getRadius: 350,
      getFillColor: [0, 229, 255, 80],
      radiusMinPixels: 2, radiusMaxPixels: 5,
    })
  ];

  if (!deckOverlay) {
    deckOverlay = new deck.MapboxOverlay({ layers, interleaved: false });
    map.addControl(deckOverlay);
  } else {
    deckOverlay.setProps({ layers });
  }
}

// ═══════════════════════════════════════════════════════
//  TREATMENT STRATEGIES
// ═══════════════════════════════════════════════════════
// Each returns a Set of cell indices to treat, given a budget in acres.

function strategyHousingProtection(budget) {
  // Treat operable cells closest to WUI, ranked by wuiWeight
  const cands = cells.filter(c => c.operable !== 'no' && c.wuiWeight > 0)
    .sort((a, b) => b.wuiWeight - a.wuiWeight);
  return allocateBudget(cands, budget);
}

function strategyHighestFuel(budget) {
  const cands = cells.filter(c => c.operable !== 'no')
    .sort((a, b) => b.fuel - a.fuel);
  return allocateBudget(cands, budget);
}

function strategyFireTransmission(budget) {
  // Score cells by: how likely fire passes through here AND reaches WUI
  // Proxy: ignProb × fuel × (inverse distance to nearest WUI)
  const scored = cells.filter(c => c.operable !== 'no').map(c => {
    let minWuiDist = Infinity;
    for (const [, clat, clng] of COMMUNITIES) {
      const d = Math.hypot(c.lat - clat, c.lng - clng);
      if (d < minWuiDist) minWuiDist = d;
    }
    const transmissionScore = c.fuel * c.ignProb / (minWuiDist + 0.01);
    return { ...c, transmissionScore };
  }).sort((a, b) => b.transmissionScore - a.transmissionScore);
  return allocateBudget(scored, budget);
}

function strategyDPV(budget) {
  // Compute DPV: run quick fire sims, score each cell by damage prevented if treated
  const dpvSims = cells.length > 10000 ? 8 : 20;
  const dpvScores = new Float32Array(cells.length);
  const sampleIgnitions = generateIgnitionSet(dpvSims);

  // Baseline: run sims with no treatment
  const baselines = [];
  for (const ign of sampleIgnitions) {
    const weather = sampleWeather();
    baselines.push(simulateFire(ign.idx, weather, null));
  }

  // For each operable cell, estimate damage reduction if treated
  const operableCells = cells.filter(c => c.operable !== 'no');
  // Sample subset for speed (test top candidates by fuel × ignProb)
  const testCells = operableCells
    .sort((a, b) => (b.fuel * b.ignProb + b.wuiWeight * 0.1) - (a.fuel * a.ignProb + a.wuiWeight * 0.1))
    .slice(0, Math.min(300, operableCells.length));

  for (const tc of testCells) {
    const treated = new Set([tc.idx]);
    let totalReduction = 0;
    for (let i = 0; i < sampleIgnitions.length; i++) {
      const weather = sampleWeather();
      const result = simulateFire(sampleIgnitions[i].idx, weather, treated);
      totalReduction += baselines[i].totalDamage - result.totalDamage;
    }
    dpvScores[tc.idx] = totalReduction / sampleIgnitions.length;
  }

  const ranked = testCells
    .map(c => ({ ...c, dpv: dpvScores[c.idx] }))
    .sort((a, b) => b.dpv - a.dpv);
  return allocateBudget(ranked, budget);
}

function strategyConstrainedDPV(budget) {
  const dpvSims = cells.length > 10000 ? 8 : 20;
  const dpvScores = new Float32Array(cells.length);
  const sampleIgnitions = generateIgnitionSet(dpvSims);
  const baselines = [];
  for (const ign of sampleIgnitions) {
    const weather = sampleWeather();
    baselines.push(simulateFire(ign.idx, weather, null));
  }

  const operableCells = cells.filter(c => c.operable !== 'no');
  const testCells = operableCells
    .sort((a, b) => (b.fuel * b.ignProb + b.wuiWeight * 0.1) - (a.fuel * a.ignProb + a.wuiWeight * 0.1))
    .slice(0, Math.min(300, operableCells.length));

  for (const tc of testCells) {
    const treated = new Set([tc.idx]);
    let totalReduction = 0;
    for (let i = 0; i < sampleIgnitions.length; i++) {
      const weather = sampleWeather();
      const result = simulateFire(sampleIgnitions[i].idx, weather, treated);
      totalReduction += baselines[i].totalDamage - result.totalDamage;
    }
    dpvScores[tc.idx] = totalReduction / sampleIgnitions.length;
  }

  // Greedy allocation with travel penalty
  const ranked = testCells.map(c => ({ ...c, dpv: dpvScores[c.idx] }))
    .sort((a, b) => b.dpv - a.dpv);

  const selected = new Set();
  let acresUsed = 0;
  let lastCell = null;
  const travelSpeed = 20; // km/h
  const hoursPerUnit = 140;
  const fleetSize = parseInt(document.getElementById('fleet-size').value) || 6;
  let totalHours = hoursPerUnit * fleetSize;

  for (const c of ranked) {
    // Travel cost from last cell
    let travelHrs = 0;
    if (lastCell) {
      const distKm = Math.hypot(c.lat - lastCell.lat, c.lng - lastCell.lng) * 111.32;
      travelHrs = distKm / travelSpeed;
    }
    const treatHrs = CELL_AREA_ACRES / 1; // 1 acre/hr
    const cost = travelHrs + treatHrs;

    if (acresUsed + CELL_AREA_ACRES > budget) break;
    if (totalHours - cost < 0) break;

    selected.add(c.idx);
    acresUsed += CELL_AREA_ACRES;
    totalHours -= cost;
    lastCell = c;
  }
  return { treated: selected, acresTreated: acresUsed };
}

// Budget allocator: greedy, accounts for travel time
function allocateBudget(rankedCells, budget) {
  const selected = new Set();
  let acresUsed = 0;
  const fleetSize = parseInt(document.getElementById('fleet-size').value) || 6;
  let totalHours = 140 * fleetSize;
  let lastCell = null;

  for (const c of rankedCells) {
    if (c.operable === 'no') continue;
    let travelHrs = 0;
    if (lastCell) {
      const distKm = Math.hypot(c.lat - lastCell.lat, c.lng - lastCell.lng) * 111.32;
      travelHrs = distKm / 20;
    }
    const treatHrs = CELL_AREA_ACRES;
    if (totalHours - travelHrs - treatHrs < 0) break;
    if (acresUsed + CELL_AREA_ACRES > budget) break;

    selected.add(c.idx);
    acresUsed += CELL_AREA_ACRES;
    totalHours -= (travelHrs + treatHrs);
    lastCell = c;
  }
  return { treated: selected, acresTreated: acresUsed };
}

// ═══════════════════════════════════════════════════════
//  MONTE CARLO RUNNER
// ═══════════════════════════════════════════════════════
let experimentResults = null;

async function runExperiment() {
  const btn = document.getElementById('btn-run');
  btn.disabled = true;
  btn.textContent = 'Running...';
  const progWrap = document.getElementById('prog-wrap');
  const prog = document.getElementById('prog');
  const status = document.getElementById('run-status');
  progWrap.style.display = 'block';

  const fleetSize = parseInt(document.getElementById('fleet-size').value) || 6;
  const budget = fleetSize * 140; // acres
  const N = cells.length > 10000 ? 30 : 100; // fewer runs for large grids

  // Generate fixed ignition set
  status.textContent = 'Generating ignition set...';
  const ignitions = generateIgnitionSet(N);

  // Pre-sample weather for each run (shared across strategies)
  const weathers = [];
  for (let i = 0; i < N; i++) weathers.push(sampleWeather());

  // Get selected strategies
  const allStrategies = [
    { name: 'Housing Protection', fn: strategyHousingProtection },
    { name: 'Fire Transmission', fn: strategyFireTransmission },
    { name: 'Highest Fuel', fn: strategyHighestFuel },
    { name: 'DPV-Optimal', fn: strategyDPV },
    { name: 'Constrained DPV', fn: strategyConstrainedDPV },
  ];
  const selectedNames = new Set();
  document.querySelectorAll('.strat-check input:checked').forEach(cb => selectedNames.add(cb.value));
  const strategies = allStrategies.filter(s => selectedNames.has(s.name));

  if (strategies.length === 0) {
    status.textContent = 'Select at least one strategy.';
    btn.disabled = false; btn.textContent = 'Run Experiment';
    return;
  }

  // Init live chart
  document.getElementById('sec-live-chart').style.display = '';
  const liveData = {}; // stratName -> [{run, damage}]
  liveData['No Treatment'] = [];
  for (const s of strategies) liveData[s.name] = [];

  // Run baseline (no treatment)
  status.textContent = 'Running baseline (no treatment)...';
  prog.style.width = '0%';
  await sleep(10);

  const baselineResults = [];
  for (let i = 0; i < N; i++) {
    const res = simulateFire(ignitions[i].idx, weathers[i], null);
    baselineResults.push(res);
    liveData['No Treatment'].push({ run: i + 1, damage: res.totalDamage });
    if (i % 10 === 0) { prog.style.width = (i/N*10) + '%'; renderLiveChart(liveData, strategies); await sleep(1); }
  }
  renderLiveChart(liveData, strategies);

  const results = {};
  const treatmentMaps = {};

  for (let s = 0; s < strategies.length; s++) {
    const strat = strategies[s];
    status.textContent = `Running: ${strat.name}...`;
    await sleep(10);

    // Generate treatment set
    const allocation = strat.fn(budget);
    const treatedSet = allocation.treated;
    const acresTreated = allocation.acresTreated;
    treatmentMaps[strat.name] = treatedSet;

    // Run MC
    const runs = [];
    for (let i = 0; i < N; i++) {
      const res = simulateFire(ignitions[i].idx, weathers[i], treatedSet);
      res.stratum = ignitions[i].stratum;
      res.weather = weathers[i].event;
      runs.push(res);
      liveData[strat.name].push({ run: i + 1, damage: res.totalDamage });
      if (i % 5 === 0) {
        const pct = 10 + (s * (90 / strategies.length)) + (i / N * (90 / strategies.length));
        prog.style.width = pct + '%';
        renderLiveChart(liveData, strategies);
        await sleep(1);
      }
    }

    // Compute summary stats
    const totalDamages = runs.map(r => r.totalDamage);
    const wuiDamages = runs.map(r => r.wuiDamage);
    const wildlandBurns = runs.map(r => r.wildlandBurned);

    const baselineMeanDmg = mean(baselineResults.map(r => r.totalDamage));
    const baselineMeanWui = mean(baselineResults.map(r => r.wuiDamage));

    // Stratum breakdown
    const byStratum = {};
    for (let q = 1; q <= 4; q++) {
      const stratumRuns = runs.filter(r => r.stratum === q);
      const stratumBase = baselineResults.filter((_, i) => ignitions[i].stratum === q);
      byStratum[q] = {
        meanDamage: mean(stratumRuns.map(r => r.totalDamage)),
        meanWui: mean(stratumRuns.map(r => r.wuiDamage)),
        baselineDamage: mean(stratumBase.map(r => r.totalDamage)),
        n: stratumRuns.length
      };
    }

    results[strat.name] = {
      runs,
      acresTreated,
      cellsTreated: treatedSet.size,
      meanDamage: mean(totalDamages),
      sdDamage: stddev(totalDamages),
      meanWui: mean(wuiDamages),
      sdWui: stddev(wuiDamages),
      meanWildland: mean(wildlandBurns),
      sdWildland: stddev(wildlandBurns),
      damageReduction: (1 - mean(totalDamages) / baselineMeanDmg) * 100,
      wuiReduction: (1 - mean(wuiDamages) / baselineMeanWui) * 100,
      wuiSavedPerAcre: (baselineMeanWui - mean(wuiDamages)) / acresTreated,
      wildlandCost: baselineMeanDmg > 0 ? (mean(wildlandBurns) - mean(baselineResults.map(r=>r.wildlandBurned))) / Math.max(1, baselineMeanWui - mean(wuiDamages)) : 0,
      byStratum
    };
  }

  // Baseline stats
  results['No Treatment'] = {
    acresTreated: 0, cellsTreated: 0,
    meanDamage: mean(baselineResults.map(r => r.totalDamage)),
    sdDamage: stddev(baselineResults.map(r => r.totalDamage)),
    meanWui: mean(baselineResults.map(r => r.wuiDamage)),
    sdWui: stddev(baselineResults.map(r => r.wuiDamage)),
    meanWildland: mean(baselineResults.map(r => r.wildlandBurned)),
    sdWildland: stddev(baselineResults.map(r => r.wildlandBurned)),
    damageReduction: 0, wuiReduction: 0, wuiSavedPerAcre: 0, wildlandCost: 0,
    byStratum: {}
  };

  experimentResults = { results, treatmentMaps, ignitions, weathers, baselineResults, fleetSize, budget };

  prog.style.width = '100%';
  status.textContent = `Done. ${N} runs × ${strategies.length + 1} conditions (incl. baseline). ${cells.length} cells.`;
  btn.disabled = false;
  btn.textContent = 'Run Experiment';

  renderResults();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function mean(arr) { return arr.length ? arr.reduce((a,b) => a+b, 0) / arr.length : 0; }
function stddev(arr) { const m = mean(arr); return Math.sqrt(mean(arr.map(x => (x-m)*(x-m)))); }

// ═══════════════════════════════════════════════════════
//  LIVE CHART (updates during MC run)
// ═══════════════════════════════════════════════════════
const STRAT_COLORS = {
  'No Treatment': '#666',
  'Housing Protection': '#7c4dff',
  'Fire Transmission': '#ff8c42',
  'Highest Fuel': '#f44336',
  'DPV-Optimal': '#00e5ff',
  'Constrained DPV': '#00e676',
};

function renderLiveChart(liveData, strategies) {
  const container = document.getElementById('chart-live');
  container.innerHTML = '';
  const W = container.clientWidth - 4, H = 150;
  const margin = { t: 8, r: 8, b: 28, l: 45 };

  // Compute running averages for each series
  const series = {};
  for (const key of Object.keys(liveData)) {
    const pts = liveData[key];
    if (pts.length === 0) continue;
    let sum = 0;
    series[key] = pts.map((p, i) => { sum += p.damage; return { run: p.run, avg: sum / (i + 1) }; });
  }

  const allPts = Object.values(series).flat();
  if (allPts.length === 0) return;

  const svg = d3.select(container).append('svg').attr('width', W).attr('height', H);
  const x = d3.scaleLinear().domain([1, 100]).range([margin.l, W - margin.r]);
  const yMax = d3.max(allPts, d => d.avg) * 1.15 || 1;
  const y = d3.scaleLinear().domain([0, yMax]).range([H - margin.b, margin.t]);

  const line = d3.line().x(d => x(d.run)).y(d => y(d.avg)).curve(d3.curveMonotoneX);

  for (const [name, pts] of Object.entries(series)) {
    svg.append('path').datum(pts)
      .attr('d', line).attr('fill', 'none')
      .attr('stroke', STRAT_COLORS[name] || '#888')
      .attr('stroke-width', name === 'No Treatment' ? 1 : 1.5)
      .attr('stroke-dasharray', name === 'No Treatment' ? '3,3' : 'none')
      .attr('opacity', 0.9);
  }

  svg.append('g').attr('transform', `translate(0,${H - margin.b})`).call(d3.axisBottom(x).ticks(5).tickFormat(d => d))
    .selectAll('text').style('fill', '#7a8299').style('font-size', '8px');
  svg.append('g').attr('transform', `translate(${margin.l},0)`).call(d3.axisLeft(y).ticks(4))
    .selectAll('text').style('fill', '#7a8299').style('font-size', '8px');
  svg.selectAll('.domain,.tick line').style('stroke', '#1e2436');

  svg.append('text').attr('x', W / 2).attr('y', H - 1).text('Run #').style('fill', '#4a5068').style('font-size', '8px').style('text-anchor', 'middle').style('font-family', 'JetBrains Mono');
  svg.append('text').attr('transform', 'rotate(-90)').attr('x', -H / 2).attr('y', 10).text('Running Avg Damage').style('fill', '#4a5068').style('font-size', '8px').style('text-anchor', 'middle').style('font-family', 'JetBrains Mono');

  // Legend
  let ly = margin.t + 2;
  for (const name of Object.keys(series)) {
    const short = name.replace('Housing Protection', 'Housing').replace('Fire Transmission', 'Transmit').replace('Highest Fuel', 'Fuel').replace('DPV-Optimal', 'DPV').replace('Constrained DPV', 'C-DPV').replace('No Treatment', 'None');
    svg.append('line').attr('x1', margin.l + 4).attr('x2', margin.l + 16).attr('y1', ly).attr('y2', ly)
      .attr('stroke', STRAT_COLORS[name] || '#888').attr('stroke-width', 1.5)
      .attr('stroke-dasharray', name === 'No Treatment' ? '3,3' : 'none');
    svg.append('text').attr('x', margin.l + 19).attr('y', ly + 3).text(short)
      .style('fill', '#7a8299').style('font-size', '7px').style('font-family', 'JetBrains Mono');
    ly += 11;
  }
}

// ═══════════════════════════════════════════════════════
//  RENDER RESULTS
// ═══════════════════════════════════════════════════════
function renderResults() {
  if (!experimentResults) return;
  const { results, treatmentMaps } = experimentResults;
  document.getElementById('sec-results').style.display = '';
  document.getElementById('sec-map-strat').style.display = '';

  // --- Main comparison table ---
  const stratNames = ['No Treatment', ...Object.keys(results).filter(n => n !== 'No Treatment')];
  let bestName = '';
  let bestDmg = Infinity;
  for (const n of stratNames) {
    if (n !== 'No Treatment' && results[n] && results[n].meanDamage < bestDmg) {
      bestDmg = results[n].meanDamage; bestName = n;
    }
  }

  let html = '<table class="results-table"><tr><th>Strategy</th><th>Damage</th><th>±SD</th><th>WUI Dmg</th><th>Wildland</th><th>Acres</th><th>Reduction</th></tr>';
  for (const n of stratNames) {
    const r = results[n];
    if (!r) continue;
    const cls = n === bestName ? ' class="best"' : '';
    html += `<tr${cls}><td>${n}</td><td>${r.meanDamage.toFixed(0)}</td><td>${r.sdDamage.toFixed(0)}</td><td>${r.meanWui.toFixed(1)}</td><td>${r.meanWildland.toFixed(0)}</td><td>${r.acresTreated.toFixed(0)}</td><td>${r.damageReduction.toFixed(1)}%</td></tr>`;
  }
  html += '</table>';
  document.getElementById('results-table-wrap').innerHTML = html;

  // --- Efficiency table ---
  let ehtml = '<table class="results-table"><tr><th>Strategy</th><th>WUI Saved/Acre</th><th>Wildland Cost/WUI</th><th>WUI Reduction</th></tr>';
  for (const n of stratNames) {
    const r = results[n];
    if (!r || n === 'No Treatment') continue;
    ehtml += `<tr><td>${n}</td><td>${r.wuiSavedPerAcre.toFixed(3)}</td><td>${r.wildlandCost.toFixed(2)}</td><td>${r.wuiReduction.toFixed(1)}%</td></tr>`;
  }
  ehtml += '</table>';
  document.getElementById('efficiency-table-wrap').innerHTML = ehtml;

  // --- Stratum table ---
  let shtml = '<table class="results-table"><tr><th>Strategy</th><th>Q1</th><th>Q2</th><th>Q3</th><th>Q4</th></tr>';
  for (const n of stratNames) {
    const r = results[n];
    if (!r || n === 'No Treatment' || !r.byStratum[1]) continue;
    shtml += `<tr><td>${n}</td>`;
    for (let q = 1; q <= 4; q++) {
      const bs = r.byStratum[q];
      const red = bs.baselineDamage > 0 ? ((1 - bs.meanDamage / bs.baselineDamage) * 100).toFixed(0) : '—';
      shtml += `<td>${red}%</td>`;
    }
    shtml += '</tr>';
  }
  shtml += '</table>';
  document.getElementById('stratum-table-wrap').innerHTML = shtml;

  // --- Damage bar chart ---
  renderDamageChart(results, stratNames);

  // --- Pareto chart ---
  renderParetoChart(results, stratNames);

  // --- Strategy map chips ---
  const chips = document.getElementById('strat-chips');
  chips.innerHTML = '';
  for (const n of stratNames) {
    if (n === 'No Treatment' || !treatmentMaps[n]) continue;
    const chip = document.createElement('span');
    chip.className = 'strat-chip';
    chip.textContent = n;
    chip.onclick = () => showTreatmentMap(n);
    chips.appendChild(chip);
  }

  // Auto-show best strategy on map
  if (bestName && treatmentMaps[bestName]) {
    showTreatmentMap(bestName);
  }
}

function renderDamageChart(results, names) {
  const container = document.getElementById('chart-damage');
  container.innerHTML = '';
  const W = container.clientWidth - 4, H = 150;
  const margin = { t: 10, r: 10, b: 40, l: 50 };

  const data = names.filter(n => results[n]).map(n => ({
    name: n.replace('No Treatment', 'None').replace('Housing Protection', 'Housing').replace('Fire Transmission', 'Transmit').replace('Highest Fuel', 'Fuel').replace('DPV-Optimal', 'DPV').replace('Constrained DPV', 'C-DPV'),
    mean: results[n].meanDamage,
    sd: results[n].sdDamage
  }));

  const svg = d3.select(container).append('svg').attr('width', W).attr('height', H);
  const x = d3.scaleBand().domain(data.map(d => d.name)).range([margin.l, W - margin.r]).padding(0.3);
  const y = d3.scaleLinear().domain([0, d3.max(data, d => d.mean + d.sd) * 1.1]).range([H - margin.b, margin.t]);

  const cArr = names.filter(n => results[n]).map(n => STRAT_COLORS[n] || '#888');

  svg.selectAll('rect').data(data).join('rect')
    .attr('x', d => x(d.name)).attr('y', d => y(d.mean))
    .attr('width', x.bandwidth()).attr('height', d => H - margin.b - y(d.mean))
    .attr('fill', (d, i) => cArr[i]).attr('rx', 2);

  // Error bars
  svg.selectAll('.err').data(data).join('line').attr('class', 'err')
    .attr('x1', d => x(d.name) + x.bandwidth()/2).attr('x2', d => x(d.name) + x.bandwidth()/2)
    .attr('y1', d => y(d.mean + d.sd)).attr('y2', d => y(Math.max(0, d.mean - d.sd)))
    .attr('stroke', '#fff').attr('stroke-width', 1).attr('opacity', 0.5);

  svg.append('g').attr('transform', `translate(0,${H-margin.b})`).call(d3.axisBottom(x))
    .selectAll('text').style('fill', '#7a8299').style('font-size', '8px').attr('transform', 'rotate(-20)').style('text-anchor', 'end');
  svg.append('g').attr('transform', `translate(${margin.l},0)`).call(d3.axisLeft(y).ticks(4))
    .selectAll('text').style('fill', '#7a8299').style('font-size', '8px');
  svg.selectAll('.domain,.tick line').style('stroke', '#1e2436');
}

function renderParetoChart(results, names) {
  const container = document.getElementById('chart-pareto');
  container.innerHTML = '';
  const W = container.clientWidth - 4, H = 150;
  const margin = { t: 10, r: 10, b: 30, l: 50 };

  const data = names.filter(n => results[n] && n !== 'No Treatment').map(n => ({
    name: n, wui: results[n].meanWui, wildland: results[n].meanWildland
  }));
  // Add baseline
  data.push({ name: 'None', wui: results['No Treatment'].meanWui, wildland: results['No Treatment'].meanWildland });

  const svg = d3.select(container).append('svg').attr('width', W).attr('height', H);
  const x = d3.scaleLinear().domain([0, d3.max(data, d => d.wildland) * 1.1]).range([margin.l, W - margin.r]);
  const y = d3.scaleLinear().domain([0, d3.max(data, d => d.wui) * 1.1]).range([H - margin.b, margin.t]);

  svg.selectAll('circle').data(data).join('circle')
    .attr('cx', d => x(d.wildland)).attr('cy', d => y(d.wui))
    .attr('r', 5).attr('fill', d => STRAT_COLORS[d.name] || '#888');

  svg.selectAll('.lbl').data(data).join('text').attr('class', 'lbl')
    .attr('x', d => x(d.wildland) + 7).attr('y', d => y(d.wui) + 3)
    .text(d => d.name.replace('Housing Protection', 'Housing').replace('Fire Transmission', 'Transmit').replace('Highest Fuel', 'Fuel').replace('Constrained DPV', 'C-DPV').replace('DPV-Optimal', 'DPV'))
    .style('fill', '#7a8299').style('font-size', '8px').style('font-family', 'JetBrains Mono');

  svg.append('g').attr('transform', `translate(0,${H-margin.b})`).call(d3.axisBottom(x).ticks(5))
    .selectAll('text').style('fill', '#7a8299').style('font-size', '8px');
  svg.append('g').attr('transform', `translate(${margin.l},0)`).call(d3.axisLeft(y).ticks(4))
    .selectAll('text').style('fill', '#7a8299').style('font-size', '8px');
  svg.selectAll('.domain,.tick line').style('stroke', '#1e2436');

  // Axis labels
  svg.append('text').attr('x', W/2).attr('y', H - 2).text('Wildland Burned (cells)').style('fill', '#4a5068').style('font-size', '8px').style('text-anchor', 'middle').style('font-family', 'JetBrains Mono');
  svg.append('text').attr('transform', 'rotate(-90)').attr('x', -H/2).attr('y', 10).text('WUI Damage').style('fill', '#4a5068').style('font-size', '8px').style('text-anchor', 'middle').style('font-family', 'JetBrains Mono');
}

function showTreatmentMap(stratName) {
  if (!experimentResults) return;
  // Reset visual state
  for (const c of cells) { c.burning = false; c.burned = false; c.treated = false; }
  // Apply treatment
  const treatedSet = experimentResults.treatmentMaps[stratName];
  if (treatedSet) {
    for (const idx of treatedSet) cells[idx].treated = true;
  }
  // Highlight chips
  document.querySelectorAll('.strat-chip').forEach(ch => {
    ch.classList.toggle('on', ch.textContent === stratName);
  });
  renderDeck();
  const nCells = treatedSet ? treatedSet.size : 0;
  const acres = nCells * CELL_AREA_ACRES;
  const info = document.getElementById('map-strat-info');
  if (info) info.textContent = `${stratName}: ${nCells} cells treated (${acres.toFixed(0)} acres). White lines = firebreak edges.`;
  log(`Showing treatment map: ${stratName} (${nCells} cells, ${acres.toFixed(0)} acres)`);
}

// ═══════════════════════════════════════════════════════
//  EXPERIMENT SWITCHER
// ═══════════════════════════════════════════════════════
function switchExperiment(exp) {
  if (exp === currentExp) return;
  currentExp = exp;
  const cfg = EXP_CONFIGS[exp];
  Object.assign(G, cfg);
  CELL_SIZE_M = G.step * 111320;
  CELL_AREA_ACRES = (CELL_SIZE_M * CELL_SIZE_M) / 4047;

  // Update header
  document.getElementById('exp-title').textContent = cfg.label;
  document.getElementById('exp-sub').textContent = cfg.sub;
  document.querySelectorAll('.exp-toggle').forEach(b => b.classList.toggle('on', +b.dataset.exp === exp));

  // Reset state
  if (fireInterval) { clearInterval(fireInterval); fireInterval = null; }
  cells.length = 0;
  for (const k of Object.keys(RC)) delete RC[k];
  nCols = 0; nRows = 0;
  experimentResults = null;
  document.getElementById('sec-results').style.display = 'none';
  document.getElementById('sec-map-strat').style.display = 'none';
  document.getElementById('sec-live-chart').style.display = 'none';
  document.getElementById('fire-log').textContent = '';

  // Rebuild
  buildGrid();
  renderDeck();
  map.flyTo({ center: cfg.center, zoom: cfg.zoom, duration: 1200 });

  // Update cell size display
  const csLabel = exp === 2 ? '~100m (~2.5 ac)' : '~1.1 km (~250 ac)';
  document.querySelector('.section .row .v').textContent; // skip — just update sidebar
  log(`Switched to ${cfg.label}: ${cells.length} cells, ${CELL_SIZE_M.toFixed(0)}m/cell, ${CELL_AREA_ACRES.toFixed(1)} ac/cell`);
  log(`Operable: ${cells.filter(c=>c.operable!=='no').length}, WUI: ${cells.filter(c=>c.wuiWeight>0).length}`);
}

// ═══════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════
buildGrid();
map.on('load', () => {
  renderDeck();
  log(`Landscape: ${cells.length} cells, ${cells.filter(c=>c.operable!=='no').length} operable, ${cells.filter(c=>c.wuiWeight>0).length} WUI`);
  log('Click a cell to ignite or press "Ignite Random Cell".');
  log('Rothermel params in sidebar. Click "Run Experiment" to compare strategies.');
});
</script>
</body>
</html>
