<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PYROSHIELD — Burnbot Treatment Optimizer</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Outfit:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/deck.gl@8.9.35/dist.min.js"></script>
<style>
:root {
  --bg: #0a0c10; --bg2: #11141c; --bg3: #181c28; --border: #1e2436;
  --text: #e8ecf4; --text2: #7a8299; --muted: #4a5068;
  --fire: #ff4d1a; --orange: #ff8c42; --cyan: #00e5ff;
  --green: #00e676; --yellow: #ffab00; --red: #f44336; --purple: #7c4dff;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family:'Outfit',sans-serif; background:var(--bg); color:var(--text); overflow:hidden; height:100vh; }
.app { display:flex; height:100vh; }

/* Sidebar */
.sidebar { width:360px; min-width:360px; background:var(--bg2); border-right:1px solid var(--border); display:flex; flex-direction:column; overflow-y:auto; z-index:10; }
.sidebar::-webkit-scrollbar { width:4px; }
.sidebar::-webkit-scrollbar-thumb { background:var(--border); border-radius:2px; }
.header { padding:20px 24px 16px; border-bottom:1px solid var(--border); }
.logo { font-family:'JetBrains Mono',monospace; font-size:18px; font-weight:700; letter-spacing:4px; background:linear-gradient(135deg,var(--orange),var(--cyan)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
.logo-sub { font-size:11px; color:var(--muted); font-family:'JetBrains Mono',monospace; margin-top:2px; }
.section { padding:16px 24px; border-bottom:1px solid var(--border); }
.section-label { font-family:'JetBrains Mono',monospace; font-size:10px; font-weight:500; letter-spacing:2px; color:var(--muted); text-transform:uppercase; margin-bottom:12px; }

/* Grid info */
.info-row { display:flex; justify-content:space-between; font-size:12px; color:var(--text2); padding:4px 0; font-family:'JetBrains Mono',monospace; }
.info-val { color:var(--text); font-weight:600; }

/* Buttons */
.btn { padding:10px 16px; border-radius:8px; border:1px solid var(--border); background:var(--bg3); color:var(--text2); font-family:'JetBrains Mono',monospace; font-size:12px; cursor:pointer; transition:all 0.2s; width:100%; text-align:center; }
.btn:hover { border-color:var(--cyan); color:var(--text); }
.btn-fire { border-color:var(--fire); color:var(--fire); }
.btn-fire:hover { background:rgba(255,77,26,0.1); }
.btn-active { border-color:var(--cyan); color:var(--cyan); background:rgba(0,229,255,0.08); }

/* Legend */
.legend { display:flex; flex-wrap:wrap; gap:10px; }
.legend-item { display:flex; align-items:center; gap:5px; font-size:11px; color:var(--text2); font-family:'JetBrains Mono',monospace; }
.legend-dot { width:10px; height:10px; border-radius:50%; }

/* Fire log */
#fire-log { font-family:'JetBrains Mono',monospace; font-size:10px; color:var(--text2); max-height:120px; overflow-y:auto; background:var(--bg); border:1px solid var(--border); border-radius:6px; padding:8px; line-height:1.6; }

/* Map */
.map-wrap { flex:1; position:relative; }
#map { width:100%; height:100%; }
</style>
</head>
<body>
<div class="app">
  <div class="sidebar">
    <div class="header">
      <div class="logo">PYROSHIELD</div>
      <div class="logo-sub">Burnbot Fleet Treatment Optimizer</div>
    </div>

    <div class="section">
      <div class="section-label">Landscape</div>
      <div class="info-row"><span>Grid</span><span class="info-val" id="info-grid">—</span></div>
      <div class="info-row"><span>Cell size</span><span class="info-val">~3 km</span></div>
      <div class="info-row"><span>Operable (≤20°)</span><span class="info-val" id="info-op">—</span></div>
      <div class="info-row"><span>Marginal (20-30°)</span><span class="info-val" id="info-marg">—</span></div>
      <div class="info-row"><span>Inoperable (>30°)</span><span class="info-val" id="info-inop">—</span></div>
      <div class="info-row"><span>Fire risk cells</span><span class="info-val" id="info-risk">—</span></div>
    </div>

    <div class="section">
      <div class="section-label">Fire Spread Test</div>
      <p style="font-size:11px;color:var(--text2);margin-bottom:10px;">Click a cell on the map to ignite, or:</p>
      <button class="btn btn-fire" onclick="igniteRandom()">Ignite Random Cell</button>
      <div style="margin-top:8px;">
        <button class="btn" onclick="resetFire()">Reset Fire</button>
      </div>
      <div style="margin-top:10px;" id="fire-log"></div>
    </div>

    <div class="section">
      <div class="section-label">Legend</div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#2e7d32"></div> Operable</div>
        <div class="legend-item"><div class="legend-dot" style="background:#f9a825"></div> Marginal</div>
        <div class="legend-item"><div class="legend-dot" style="background:#c62828"></div> Inoperable</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--fire);box-shadow:0 0 6px var(--fire)"></div> Burning</div>
        <div class="legend-item"><div class="legend-dot" style="background:#333"></div> Burned</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--cyan)"></div> FIRMS hotspot</div>
      </div>
    </div>

    <div class="section">
      <div class="section-label">Data Sources</div>
      <div style="font-size:11px;color:var(--text2);font-family:'JetBrains Mono',monospace;line-height:1.8;">
        Fire ignition: NASA FIRMS VIIRS (embedded snapshot)<br>
        Elevation: Open-Meteo Copernicus DEM (embedded)<br>
        Wind: Open-Meteo GFS (embedded snapshot)<br>
        Burnbot specs: RX2 — 1 acre/hr, ≤20mph wind, ≤30° slope
      </div>
    </div>
  </div>

  <div class="map-wrap">
    <div id="map"></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════
//  EMBEDDED DATA
// ═══════════════════════════════════════════════

// FIRMS historical hotspots — real coords from Camp Fire / Dixie Fire / North Complex
const FIRMS = [
  [39.764,-121.606,142],[39.778,-121.585,118],[39.751,-121.622,135],[39.790,-121.570,89],
  [39.740,-121.640,110],[39.802,-121.555,76],[39.770,-121.615,128],[39.755,-121.590,95],
  [40.140,-121.180,165],[40.120,-121.150,140],[40.160,-121.200,115],[40.100,-121.130,100],
  [40.180,-121.220,125],[40.080,-121.100,88],[40.150,-121.170,148],[40.200,-121.250,80],
  [39.820,-121.400,105],[39.840,-121.380,92],[39.800,-121.420,112],[39.860,-121.360,85],
  [39.780,-121.440,130],[39.880,-121.350,70],[39.830,-121.390,108],[39.810,-121.410,97],
  [39.750,-121.500,65],[39.730,-121.520,58],[39.770,-121.480,82],[39.710,-121.540,68],
  [39.900,-121.300,62],[39.920,-121.320,55],[39.880,-121.280,72],[39.940,-121.340,50],
  [39.720,-121.650,90],[39.700,-121.680,82],[39.740,-121.620,100],[39.760,-121.580,86],
  [40.050,-121.080,106],[40.030,-121.050,90],[40.070,-121.100,120],[40.010,-121.020,80],
  [40.090,-121.120,112],[39.990,-121.000,75],[40.040,-121.070,132],[40.020,-121.030,88],
  [39.850,-121.700,60],[39.830,-121.720,52],[39.870,-121.680,66],[39.890,-121.660,48]
]; // [lat, lng, frp]

// Wind — single representative profile (NW wind, moderate)
const WIND = { speed_ms: 6.5, dir_deg: 315 }; // NW at ~15mph

// Elevation grid — we'll build this with realistic values
// Sierra foothills: valley ~60m west, rising to ~2000m east
const GRID = { lngMin:-121.85, lngMax:-120.95, latMin:39.60, latMax:40.30, step:0.03 };

// ═══════════════════════════════════════════════
//  BUILD LANDSCAPE GRID
// ═══════════════════════════════════════════════
const cells = [];
const cellsByRC = {};; // row,col -> cell index
let nCols = 0, nRows = 0;

function buildGrid() {
  let row = 0;
  for (let lat = GRID.latMin; lat <= GRID.latMax; lat += GRID.step) {
    let col = 0;
    for (let lng = GRID.lngMin; lng <= GRID.lngMax; lng += GRID.step) {
      // Elevation model: rises from west (~60m) to east (~2000m) with ridge noise
      const eastFrac = (lng - GRID.lngMin) / (GRID.lngMax - GRID.lngMin);
      const baseElev = 60 + eastFrac * 1800;
      const ridge = Math.sin(lat * 80) * 120 + Math.cos(lng * 60) * 80;
      const canyon = Math.sin((lat + lng) * 40) * 100;
      const elev = Math.max(30, baseElev + ridge + canyon);

      // Fuel load: higher at mid-elevations (chaparral/mixed conifer), lower at valley floor and high peaks
      const elevNorm = Math.min(1, elev / 2000);
      const fuelBase = Math.sin(elevNorm * Math.PI) * 0.8; // peaks at mid-elevation
      const fuelNoise = (Math.sin(lat * 100 + lng * 77) * 0.5 + 0.5) * 0.3;
      const fuel = Math.max(0.05, Math.min(1, fuelBase + fuelNoise));

      // Ignition probability from FIRMS density
      let ignitionBoost = 0;
      FIRMS.forEach(([flat, flng, frp]) => {
        const d = Math.hypot(lat - flat, lng - flng);
        if (d < 0.08) ignitionBoost += (frp / 165) * (1 - d / 0.08);
      });
      const ignitionProb = Math.min(1, 0.02 + ignitionBoost * 0.15);

      const idx = cells.length;
      cellsByRC[`${row},${col}`] = idx;
      cells.push({
        row, col, lat: parseFloat(lat.toFixed(4)), lng: parseFloat(lng.toFixed(4)),
        elevation: elev, fuel, ignitionProb,
        slope: 0, operable: 'yes', // computed after grid is built
        burning: false, burned: false, treated: false, burnTimer: 0
      });
      col++;
    }
    if (row === 0) nCols = col;
    row++;
  }
  nRows = row;

  // Compute slope between adjacent cells
  const cellSizeM = GRID.step * 111320;
  cells.forEach((cell, i) => {
    let maxSlope = 0;
    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc]) => {
      const ni = cellsByRC[`${cell.row+dr},${cell.col+dc}`];
      if (ni !== undefined) {
        const dElev = Math.abs(cells[ni].elevation - cell.elevation);
        maxSlope = Math.max(maxSlope, Math.atan(dElev / cellSizeM) * 180 / Math.PI);
      }
    });
    cell.slope = maxSlope;
    cell.operable = maxSlope <= 20 ? 'yes' : maxSlope <= 30 ? 'marginal' : 'no';
  });

  // Update sidebar
  const op = cells.filter(c => c.operable === 'yes').length;
  const marg = cells.filter(c => c.operable === 'marginal').length;
  const inop = cells.filter(c => c.operable === 'no').length;
  const risk = cells.filter(c => c.ignitionProb > 0.05).length;
  document.getElementById('info-grid').textContent = `${nRows}×${nCols} (${cells.length} cells)`;
  document.getElementById('info-op').textContent = `${op} (${(op/cells.length*100).toFixed(0)}%)`;
  document.getElementById('info-marg').textContent = `${marg} (${(marg/cells.length*100).toFixed(0)}%)`;
  document.getElementById('info-inop').textContent = `${inop} (${(inop/cells.length*100).toFixed(0)}%)`;
  document.getElementById('info-risk').textContent = `${risk}`;
}

// ═══════════════════════════════════════════════
//  FIRE SPREAD — Cellular Automaton
// ═══════════════════════════════════════════════
let fireInterval = null;
const SPREAD_BASE = 0.35; // base probability of spreading to neighbor per tick

function igniteCell(idx) {
  if (idx < 0 || idx >= cells.length) return;
  const c = cells[idx];
  if (c.burning || c.burned || c.treated) return;
  c.burning = true;
  c.burnTimer = 0;
  log(`Ignited cell [${c.row},${c.col}] — elev ${c.elevation.toFixed(0)}m, fuel ${(c.fuel*100).toFixed(0)}%, slope ${c.slope.toFixed(1)}°`);
  if (!fireInterval) startFireLoop();
}

function igniteRandom() {
  // Pick from high-ignition-probability cells
  const candidates = cells.filter(c => !c.burning && !c.burned && !c.treated && c.ignitionProb > 0.05);
  if (candidates.length === 0) return;
  // Weighted random by ignition probability
  const totalProb = candidates.reduce((s, c) => s + c.ignitionProb, 0);
  let r = Math.random() * totalProb;
  for (const c of candidates) {
    r -= c.ignitionProb;
    if (r <= 0) { igniteCell(cells.indexOf(c)); return; }
  }
  igniteCell(cells.indexOf(candidates[candidates.length - 1]));
}

function spreadFire() {
  const toIgnite = [];
  const toBurnOut = [];

  cells.forEach((cell, i) => {
    if (!cell.burning) return;
    cell.burnTimer++;

    // Burn out after fuel is consumed (higher fuel = longer burn)
    if (cell.burnTimer > 3 + cell.fuel * 8) {
      toBurnOut.push(i);
      return;
    }

    // Try to spread to 4 neighbors
    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc]) => {
      const ni = cellsByRC[`${cell.row+dr},${cell.col+dc}`];
      if (ni === undefined) return;
      const nb = cells[ni];
      if (nb.burning || nb.burned || nb.treated) return;

      // Spread probability depends on:
      // 1. Neighbor's fuel load (more fuel = easier to ignite)
      // 2. Slope (fire spreads faster uphill)
      // 3. Wind (spreads faster downwind)
      let prob = SPREAD_BASE * nb.fuel;

      // Slope effect: uphill increases spread
      const elevDiff = nb.elevation - cell.elevation;
      if (elevDiff > 0) prob *= 1 + (elevDiff / 200); // uphill boost
      else prob *= Math.max(0.3, 1 + elevDiff / 500); // downhill penalty

      // Wind effect: NW wind pushes fire SE
      const windRad = (WIND.dir_deg - 180) * Math.PI / 180; // direction fire travels
      const spreadDir = Math.atan2(dc, dr); // direction of this neighbor
      const windAlign = Math.cos(spreadDir - windRad);
      const windFactor = 1 + windAlign * (WIND.speed_ms / 10);
      prob *= Math.max(0.2, windFactor);

      prob = Math.min(0.95, prob);
      if (Math.random() < prob) toIgnite.push(ni);
    });
  });

  toBurnOut.forEach(i => { cells[i].burning = false; cells[i].burned = true; });
  toIgnite.forEach(i => {
    if (!cells[i].burning && !cells[i].burned) {
      cells[i].burning = true;
      cells[i].burnTimer = 0;
    }
  });

  renderDeck();

  // Check if fire is still active
  if (!cells.some(c => c.burning)) {
    clearInterval(fireInterval);
    fireInterval = null;
    const burnedCount = cells.filter(c => c.burned).length;
    log(`Fire out. ${burnedCount} cells burned (${(burnedCount/cells.length*100).toFixed(1)}% of landscape).`);
  }
}

function startFireLoop() {
  if (fireInterval) return;
  fireInterval = setInterval(spreadFire, 200);
}

function resetFire() {
  if (fireInterval) { clearInterval(fireInterval); fireInterval = null; }
  cells.forEach(c => { c.burning = false; c.burned = false; c.burnTimer = 0; });
  document.getElementById('fire-log').textContent = '';
  renderDeck();
}

function log(msg) {
  const el = document.getElementById('fire-log');
  el.textContent += msg + '\n';
  el.scrollTop = el.scrollHeight;
}

// ═══════════════════════════════════════════════
//  MAP + DECK.GL
// ═══════════════════════════════════════════════
const map = new maplibregl.Map({
  container: 'map',
  style: {
    version: 8,
    sources: { 'carto': { type:'raster', tiles:['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'], tileSize:256 }},
    layers: [{ id:'carto', type:'raster', source:'carto' }]
  },
  center: [-121.35, 39.95], zoom: 9, pitch: 0, maxZoom: 13, minZoom: 7
});

let deckOverlay = null;

function cellColor(c) {
  if (c.burning) return [255, 60, 10, 200];
  if (c.burned) return [40, 40, 40, 160];
  if (c.treated) return [0, 150, 255, 120];
  // Operability coloring with fuel intensity
  const f = c.fuel;
  if (c.operable === 'yes') return [30 + f*20, 100 + f*25, 40, 50 + f*60];
  if (c.operable === 'marginal') return [200, 160, 30, 50 + f*60];
  return [180, 30, 30, 50 + f*60];
}

function renderDeck() {
  const layers = [
    new deck.ScatterplotLayer({
      id: 'grid',
      data: cells,
      getPosition: d => [d.lng, d.lat],
      getRadius: 1200,
      getFillColor: d => cellColor(d),
      radiusMinPixels: 4,
      radiusMaxPixels: 18,
      pickable: true,
      onClick: ({object}) => { if (object) igniteCell(cells.indexOf(object)); },
      updateTriggers: { getFillColor: [Date.now()] }
    }),
    // FIRMS hotspots as cyan dots
    new deck.ScatterplotLayer({
      id: 'firms',
      data: FIRMS,
      getPosition: d => [d[1], d[0]],
      getRadius: 400,
      getFillColor: [0, 229, 255, 100],
      radiusMinPixels: 2,
      radiusMaxPixels: 6,
    })
  ];

  if (!deckOverlay) {
    deckOverlay = new deck.MapboxOverlay({ layers, interleaved: false });
    map.addControl(deckOverlay);
  } else {
    deckOverlay.setProps({ layers });
  }
}

// ═══════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════
buildGrid();
map.on('load', () => {
  renderDeck();
  log('Landscape ready. Click a cell or press "Ignite Random Cell".');
});
</script>
</body>
</html>
